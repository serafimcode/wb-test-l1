package main

import (
	"fmt"
)

/*Быстрая сортировка разбиение Хоара(единственное, которое я более-менее помню)*/
func quickSort(arr []int, lIdx, rIdx int) {
	/*База рекурсии, если в результате разбиения левая граница вышла за правую,
	значит сортировка закончена*/
	if lIdx >= rIdx {
		return
	}
	/*Вызыавем само разбиение, в результате которого получим индекс нового опорного элемента.
	На данном этапе опорный элемент- это элемент слева от которого расположены меньшие зн-я,
	а справа большие*/
	pivotIdx := partitioning(arr, lIdx, rIdx)
	/*Повторяем все что выше для левой и правой половин*/
	quickSort(arr, lIdx, pivotIdx-1)
	quickSort(arr, pivotIdx+1, rIdx)
}

/*Само разбиение*/
func partitioning(arr []int, lIdx, rIdx int) int {
	/*Определяем индекс опорного элемента, как самый левый элемент.
	Позиция элемента роли не играет.*/
	pivotIdx := lIdx
	i, j := lIdx+1, rIdx

	for {
		/*Начиная с левой границы ищем индекс(i) элемента,
		который будет больше опорного элемента*/
		for i < rIdx && arr[i] < arr[pivotIdx] {
			i++
		}
		/*Начиная с правой границы ищем индекс(j) элемента,
		который будет меньше опорного элемента*/
		for j > lIdx && arr[j] > arr[pivotIdx] {
			j--
		}
		/*Если i вышале за j, значит массив отсортировон(почти).
		На этом этапе у нас ситуация [pivot, ..., j, i, ...].
		Все что слева от j, меньше чем pivot, все что справа от i больше чем pivot.
		Осталось поменять pivot с j.*/
		if i >= j {
			arr[pivotIdx], arr[j] = arr[j], arr[pivotIdx]
			return j
		} else {
			/*Если i не вышел за j, значит сейчас мы имеем
			arr[i] > pivot, а arr[j] < pivot, при этом j > i.
			Меняем местами и идем дальше*/
			arr[i], arr[j] = arr[j], arr[i]
			i++
			j--
		}
	}

}

func main() {
	arr := []int{-5, 0, 1, 5, -10, -10, 5, 9}
	quickSort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}
